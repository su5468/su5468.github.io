---
layout: posts
categories:
    - BOJ
title: BOJ 2226 이진수
---

[문제 링크](https://www.acmicpc.net/problem/2226)

간단한 DP 문제.  
어려운 문제는 아니지만 수의 범위가 커서 파이썬이 아니었다면 애먹었을 수 있는 문제.  
사실 연속된 0이 나오는 횟수에 규칙이 있어 몇번 해보면 금방 답이 나오지만, 그 몇번을 안 해보고 머리로만 풀었더니 조금 돌아서 풀게 되었다.  
걸리는 시간은 정해랑 10ms정도밖에 차이가 안 나서 무의미하다고는 생각하지만...  
아무튼, 정해는 나오는 0의 수가 짝수 번째 항에서는 `*2+1`이 되고, 홀수 번째 항에서는 `*2-1`이 되는 것을 이용해서 푸는 것이다.  
나는 어떻게 풀었느냐, 항의 각 숫자를 4가지로 구분했다. 1 다음에 오는 1, 1 다음에 오는 0, 0 다음에 오는 1, 0 다음에 오는 0이다.  
그 다음, 각 경우에 대해서 다음 숫자가 어떻게 변할지를 알려주는 `add` 리스트를 만들었다.  
예를 들어 `add[0] = [0, 1, 1, 0]`인데, 1 다음에 오는 1은 1 다음에 오는 0과 0 다음에 오는 1로 변화한다는 뜻이다.  
그렇다면 맨 앞의 숫자는 어떻게 구분하는가? 사실 이 수는 1, 0, 1, 0, ...으로 번갈아가면서 바뀐다.  
따라서, 맨 앞의 두 수는 10, 01, 10, 01, ...로 바뀔 것이다.  
4가지 숫자로 답을 어떻게 알아낸다는 것인가 하면, 1은 01로 바뀌기 때문에 마지막 숫자는 항상 1이다.  
그 말은, 0 다음의 1이 등장하는 횟수는 연속된 0이 등장하는 횟수와 같다는 뜻이다.  
그래서 0 다음에 오는 1의 개수를 세어주면 그게 답이 된다.

```python
#!python

n = int(input())

dp = [[0, 0, 0, 0] for _ in range(n)]

# 1 다음의 1, 1 다음의 0, 0 다음의 1, 0 다음의 0이 각각 다음 항에서 어떤 숫자로 바뀌는지를 매핑함
add = [[0, 1, 1, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0]]

# dp 실행
for i in range(1, n):
    for j in range(4):
        for k in range(4):
            # 4가지 숫자의 개수를 갱신한다
            dp[i][j] += dp[i-1][k] * add[k][j]
    # 맨 앞에 있는 10, 01, 10, 01...을 개수에 더해준다
    if i % 2 == 0:
        dp[i][1] += 1
    else:
        dp[i][2] += 1

# 0 다음에 오는 1(01)의 개수가 답이 된다
print(dp[-1][2])
```
