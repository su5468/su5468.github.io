---
layout: posts
categories:
    - BOJ
title: 백준(BOJ) 1135 뉴스 전하기 파이썬(Python)
---

[문제 링크](https://www.acmicpc.net/problem/1135)

간단한 트리에서의 DP 문제.  
한 노드에서 자식 노드들에 소식을 전부 전파하는 데에 걸리는 시간은 단말 노드에서 0(전파할 부하가 없으므로), 단말이 아닌 노드에서 $$\max (c_{i} + \mathrm{rank}(c_{i}))$$로 나타낼 수 있다.  
이때, $$c_{i}$$는 노드의 $$i$$번째 자식의 답(즉, $$i$$번째 자식에서 소식을 전부 전파하는 데에 걸리는 시간)이고, $$\mathrm {rank}(c_{i})$$는 $$i$$번째 자식 이상인 답을 가지는 형제 노드의 개수(자신 포함)이다.  
예를 들어, 어떤 노드에 대해, 3개의 자식 노드가 각각 답이 4, 4, 5라고 하자.  
그렇다면 값이 5 이상인 노드는 1개이므로 $$5 + 1$$, 4 이상인 노드는 3개이므로 $$4 + 3$$이 되어 최종적으로 더 큰 값인 $$7$$이 선택된다.  
이런 점화식이 유도될 수 있는 이유에 대해 생각해보자.  
우선, 소식을 전파하는 데에 오래 걸리는 자식 노드(즉, 답이 큰 노드)에게 먼저 연락해야 하는 것은 자명하다.  
따라서, 연락 순서는 값이 큰 노드부터 작은 노드 순이 될 것이다.  
값이 $$x$$ 이상인 자식 노드가 $$\mathrm{rank}(x)$$개 있다면 걸리는 총 시간은 자식 노드가 소식을 전파하는 시간 $$x$$, 현재 노드에서 그 자식 노드 이전에 연락하는 데에 걸리는 시간 $$\mathrm{rank}(x) - 1$$(자기 자신을 제외해야 하므로), 현재 노드에서 자식 노드로 연락하는 시간 $$1$$을 모두 더한 값이 된다.  
이는 $$x + \mathrm{rank}(x) - 1 + 1 = x + \mathrm{rank}(x)$$가 된다.  
따라서 그러한 값 중 최댓값을 찾아서 현재 노드의 값을 계산하고, 재귀적으로 상위 노드의 값도 계산해주면 된다.  
이때, 직원 $$i$$의 상사는 $$i$$ 이하의 값을 가지므로 간단하게 역순으로 순회하는 것을 통해 단말 노드부터 답을 계산해줄 수 있다.  


```python
#!python

n = int(input())
graph = [[] for _ in range(n)]
# node[i]는 i번째 노드에서 뉴스를 전부 전달하는 데에 걸리는 시간
node = [0] * n

# 그래프(트리) 구성
for i, p in enumerate(list(map(int, input().split()))[1:], 1):
    graph[p].append(i)

# 번호가 작은 노드부터 위에 있음이 보장되므로 그냥 역순으로 순회하면 트리 아래에서부터 시작하게 된다
for i in range(n - 1, -1, -1):
    # 현재 노드의 값(node[i]) = max(node[child] + rank(node[child]))
    # 이때, rank(x)는 형제 노드들 중 값이 x 이상인 것의 개수
    # 각 값당 한번씩만 계산해도 되므로 set(graph[i])를 쓰면 상황에 따라 더 빨리 계산할 수 있다
    for child in graph[i]:
        node[i] = max(node[i], node[child] + sum((node[j] >= node[child] for j in graph[i])))

print(node[0])

```
